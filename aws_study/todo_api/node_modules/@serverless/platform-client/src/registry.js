/*
 * SERVERLESS PLATFORM SDK: REGISTRY
 */

const path = require('path')
const fs = require('fs')
const { tmpdir } = require('os')
const axios = require('axios')
const utils = require('./utils')

/**
 * Validates and (re)formats the package properties
 */
const validateAndFormat = (registryPackageRaw) => {
  // Copy input object, otherwise the inputter will have unintended data modifications
  const registryPackage = Object.assign({}, registryPackageRaw)

  if (!registryPackage.name) {
    throw new Error(`The 'name' property is required`)
  }

  if (!registryPackage.version) {
    throw new Error(`The 'version' property is required`)
  }

  // Ensure "dev" version uses correct syntax
  if (registryPackage.version === 'dev') {
    registryPackage.version = '0.0.0-dev'
  }

  // Format Helper - If shortened properties are used, replace them with full properties
  if (registryPackage.org) {
    registryPackage.orgName = registryPackage.org
    delete registryPackage.org
  }

  if (!registryPackage.orgName) {
    throw new Error(`'orgName' is required`)
  }
  if (!registryPackage.src) {
    throw new Error(`'src' is required`)
  }
  if (!registryPackage.type) {
    throw new Error(`'type' is required`)
  }

  return registryPackage
}

/*
 * Reads a package config from the config file
 */
const getPackageConfig = (directoryPath) => {
  directoryPath = path.resolve(directoryPath)
  const ymlFilePath = path.join(directoryPath, 'serverless.yml')
  const yamlFilePath = path.join(directoryPath, 'serverless.yaml')
  const jsonFilePath = path.join(directoryPath, 'serverless.json')
  let filePath

  // Check to see if exists and is yaml or json file
  if (utils.fileExistsSync(ymlFilePath)) {
    filePath = ymlFilePath
  }
  if (utils.fileExistsSync(yamlFilePath)) {
    filePath = yamlFilePath
  }
  if (utils.fileExistsSync(jsonFilePath)) {
    filePath = jsonFilePath
  }
  if (!filePath) {
    return null
  }

  const packageConfig = {}
  packageConfig.fileName = path.basename(filePath)
  packageConfig.fileContent = fs.readFileSync(filePath, 'utf-8')

  return packageConfig
}

/*
 * Zips a package for publishing
 */
const zipPackage = async (registryPackage) => {
  // Get Registry path and temporary path for packaging
  const registryPackagePath = path.join(
    tmpdir(),
    `${Math.random()
      .toString(36)
      .substring(6)}.zip`
  )

  const includeContent = []
  const exclude = []
  if (registryPackage.type === 'component') {
    // If packaging component, add the special "handler.js"
    includeContent.push({
      fileName: '_handler.js',
      fileContent: `const { handler } = require('@serverless/core');module.exports.handler = handler;`
    })
  } else {
    // if publishing template, exclude node_modules and any .env files.
    exclude.push('**/node_modules/**')
    exclude.push('**/.env')
    exclude.push('**/.env.*')
  }

  // get package config from the config file from inside the src
  const packageConfig = getPackageConfig(registryPackage.src)

  // if there is a config file in the src, make sure to remove these properties
  if (packageConfig) {
    // remove these properties from the serverless config file
    packageConfig.fileContent = packageConfig.fileContent
      .replace(/org\s*:.+\n/gi, () => ``)
      .replace(/description\s*:.+\n/gi, () => ``)
      .replace(/keywords\s*:.+\n/gi, () => ``)
      .replace(/repo\s*:.+\n/gi, () => ``)
      .replace(/license\s*:.+\n/gi, () => ``)

    // update the serverless config file without the above properties
    includeContent.push(packageConfig)
  }

  await utils.zip(registryPackage.src, registryPackagePath, [], exclude, includeContent)

  return registryPackagePath
}

/**
 * Publish to the Registry
 */
const publish = async (sdk, registryPackage) => {
  // Validate
  registryPackage = validateAndFormat(registryPackage)

  // Pre-Publish gets a pre-signed URL for upload and a bucket key
  const preResponse = await utils.request({
    endpoint: `${sdk.getDomain('registry')}/packages/prePublish`,
    accessKey: sdk.accessKey,
    method: 'POST',
    data: registryPackage
  })

  const { packageUploadUrl, packageKey } = preResponse

  const registryPackagePath = await zipPackage(registryPackage)

  // Axios auto-adds headers that causes signature mismatch
  // So we remove them manually
  const request = axios.create()
  request.defaults.headers.common = {}
  request.defaults.headers.put = {}
  const file = fs.readFileSync(registryPackagePath)

  // Make sure axios handles large packages
  const config = {
    maxContentLength: Infinity,
    maxBodyLength: Infinity
  }

  // Upload
  await request.put(packageUploadUrl, file, config)

  // Post-Publish sends a bucket key to finalize publishing and create a lambda funnction if applicable
  return utils.request({
    endpoint: `${sdk.getDomain('registry')}/packages/postPublish`,
    accessKey: sdk.accessKey,
    method: 'POST',
    data: {
      orgName: registryPackage.orgName,
      packageKey
    }
  })
}

/**
 * Fetches a package from the Registry
 */
const get = async (sdk, name, version) => {
  let endpoint = `${sdk.getDomain('registry')}/packages`

  if (name) {
    endpoint = `${endpoint}/${name}`
  }

  if (version) {
    endpoint = `${endpoint}/${version}`
  }

  const data = await utils.request({
    accessKey: sdk.accessKey,
    endpoint,
    method: `GET`
  })

  // exclude these properties from the response,
  // which is returned only for backward compatability
  // newer clients (using this version of the sdk)
  // should ignore these properties
  delete data.componentName
  delete data.component
  delete data.componentDefinition

  // remove versioning props in case of templates
  if (data.type === 'template') {
    delete data.version
    delete data.versions
  }

  return data
}

module.exports = {
  get,
  publish
}
